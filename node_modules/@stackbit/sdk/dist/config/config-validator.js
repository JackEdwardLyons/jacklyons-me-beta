"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContentModels = exports.validateConfig = void 0;
const lodash_1 = __importDefault(require("lodash"));
const config_schema_1 = require("./config-schema");
const config_errors_1 = require("./config-errors");
function validateConfig(config) {
    const validationOptions = { abortEarly: false };
    const validationResult = config_schema_1.stackbitConfigSchema.validate(config, validationOptions);
    const value = validationResult.value;
    const errors = mapJoiErrorsToConfigValidationErrors(validationResult);
    const valid = lodash_1.default.isEmpty(errors);
    markInvalidModels(value, errors, 'models');
    return {
        value,
        valid,
        errors
    };
}
exports.validateConfig = validateConfig;
function validateContentModels(contentModels, models) {
    const validationResult = config_schema_1.contentModelsSchema.validate({ contentModels: contentModels }, {
        abortEarly: false,
        context: {
            models: models
        }
    });
    const value = validationResult.value;
    const errors = mapJoiErrorsToConfigValidationErrors(validationResult);
    const valid = lodash_1.default.isEmpty(errors);
    markInvalidModels(value, errors, 'contentModels');
    return {
        value,
        valid,
        errors
    };
}
exports.validateContentModels = validateContentModels;
function mapJoiErrorsToConfigValidationErrors(validationResult) {
    var _a;
    const joiErrors = ((_a = validationResult.error) === null || _a === void 0 ? void 0 : _a.details) || [];
    return joiErrors.map((validationError) => {
        var _a;
        return new config_errors_1.ConfigValidationError({
            type: validationError.type,
            message: validationError.message,
            fieldPath: validationError.path,
            value: (_a = validationError.context) === null || _a === void 0 ? void 0 : _a.value
        });
    });
}
function markInvalidModels(config, errors, configKey) {
    var _a;
    const invalidModelNames = getInvalidModelNames(errors, configKey);
    const models = (_a = config[configKey]) !== null && _a !== void 0 ? _a : {};
    lodash_1.default.forEach(models, (model, modelName) => {
        if (invalidModelNames.includes(modelName)) {
            lodash_1.default.set(model, '__metadata.invalid', true);
        }
    });
}
function getInvalidModelNames(errors, configKey) {
    // get array of invalid model names by iterating errors and filtering these
    // having fieldPath starting with ['models', modelName]
    return lodash_1.default.reduce(errors, (modelNames, error) => {
        if (error.fieldPath[0] === configKey && typeof error.fieldPath[1] == 'string') {
            const modelName = error.fieldPath[1];
            modelNames.push(modelName);
        }
        return modelNames;
    }, []);
}
//# sourceMappingURL=config-validator.js.map