"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfigFromDir = exports.validateAndNormalizeConfig = exports.extendConfig = exports.loadConfig = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const semver_1 = __importDefault(require("semver"));
const lodash_1 = __importDefault(require("lodash"));
const config_validator_1 = require("./config-validator");
const config_errors_1 = require("./config-errors");
const config_loader_esbuild_1 = require("./config-loader-esbuild");
const utils_1 = require("../utils");
const utils_2 = require("@stackbit/utils");
const presets_loader_1 = require("./presets-loader");
async function loadConfig({ dirPath, modelsSource, stackbitConfigESBuildOutDir, watchCallback }) {
    const rawConfigResult = await loadConfigFromDir({
        dirPath,
        stackbitConfigESBuildOutDir,
        watchCallback: watchCallback
            ? async (rawConfigResult) => {
                const configLoaderResult = await processConfigLoaderResult({ rawConfigResult, dirPath, modelsSource });
                watchCallback(configLoaderResult);
            }
            : undefined
    });
    const configLoaderResult = await processConfigLoaderResult({ rawConfigResult, dirPath, modelsSource });
    return Object.assign(configLoaderResult, { stop: rawConfigResult.stop });
}
exports.loadConfig = loadConfig;
async function processConfigLoaderResult({ rawConfigResult, dirPath, modelsSource }) {
    const { config, errors: configLoadErrors } = rawConfigResult;
    if (!config) {
        return {
            valid: false,
            config: null,
            errors: configLoadErrors
        };
    }
    const { models: externalModels, errors: externalModelsLoadErrors } = await loadModelsFromExternalSource(config, dirPath, modelsSource);
    const extendedConfig = await extendConfig({ dirPath, config, externalModels });
    return {
        valid: extendedConfig.valid,
        config: extendedConfig.config,
        errors: [...configLoadErrors, ...externalModelsLoadErrors, ...extendedConfig.errors]
    };
}
async function extendConfig({ dirPath, config, externalModels }) {
    const normalizedResult = validateAndNormalizeConfig(config, externalModels);
    const presetsResult = await presets_loader_1.loadPresets(dirPath, normalizedResult.config);
    return {
        valid: normalizedResult.valid,
        config: presetsResult.config,
        errors: [...normalizedResult.errors, ...presetsResult.errors]
    };
}
exports.extendConfig = extendConfig;
function validateAndNormalizeConfig(config, externalModels) {
    // extend config models having the "extends" property
    // this must be done before any validation as some properties like
    // the labelField will not work when validating models without extending them first
    const { models: extendedModels, errors: extendModelErrors } = utils_1.extendModelMap(config.models);
    const extendedConfig = {
        ...config,
        models: extendedModels
    };
    const { config: mergedConfig, errors: externalModelsMergeErrors } = mergeConfigWithExternalModels(extendedConfig, externalModels);
    // validate the "contentModels" and extend config models with "contentModels"
    // this must be done before main config validation to make it independent of "contentModels".
    const { value: configWithContentModels, errors: contentModelsErrors } = validateAndExtendContentModels(mergedConfig);
    // normalize config - backward compatibility updates, adding extra fields like "markdown_content", "type" and "layout",
    // and setting other default values.
    const normalizedConfig = normalizeConfig(configWithContentModels);
    // validate config
    const { value: validatedConfig, errors: validationErrors } = config_validator_1.validateConfig(normalizedConfig);
    const errors = [...extendModelErrors, ...externalModelsMergeErrors, ...contentModelsErrors, ...validationErrors];
    return normalizeValidationResult({
        valid: lodash_1.default.isEmpty(errors),
        value: validatedConfig,
        errors: errors
    });
}
exports.validateAndNormalizeConfig = validateAndNormalizeConfig;
async function loadConfigFromDir({ dirPath, stackbitConfigESBuildOutDir, watchCallback }) {
    var _a;
    // try to load stackbit config from YAML files
    try {
        const stackbitYamlPath = path_1.default.join(dirPath, 'stackbit.yaml');
        const stackbitYamlExists = await fs_extra_1.default.pathExists(stackbitYamlPath);
        if (stackbitYamlExists) {
            const stackbitYamlResult = await loadConfigFromStackbitYaml(stackbitYamlPath);
            if (stackbitYamlResult.error) {
                return { errors: [stackbitYamlResult.error] };
            }
            const { models: modelsFromFiles, errors: fileModelsErrors } = await loadModelsFromFiles(dirPath, stackbitYamlResult.config);
            const mergedModels = mergeConfigModelsWithModelsFromFiles((_a = stackbitYamlResult.config.models) !== null && _a !== void 0 ? _a : {}, modelsFromFiles);
            return {
                config: {
                    ...stackbitYamlResult.config,
                    models: mergedModels
                },
                errors: fileModelsErrors
            };
        }
    }
    catch (error) {
        return {
            errors: [new config_errors_1.ConfigLoadError(`Error loading Stackbit configuration: ${error.message}`, { originalError: error })]
        };
    }
    function wrapResult(result) {
        if (result.error) {
            return {
                errors: [result.error]
            };
        }
        else {
            return {
                config: result.config,
                errors: []
            };
        }
    }
    // try to load stackbit config from JavaScript files
    try {
        const configFilePath = await utils_2.getFirstExistingFile(['stackbit.config.js', 'stackbit.config.cjs', 'stackbit.config.mjs', 'stackbit.config.ts'], dirPath);
        if (configFilePath) {
            const configResult = await config_loader_esbuild_1.loadStackbitConfigFromJs({
                configPath: configFilePath,
                outDir: stackbitConfigESBuildOutDir,
                watch: !!watchCallback,
                callback: watchCallback
                    ? (result) => {
                        watchCallback(wrapResult(result));
                    }
                    : undefined
            });
            return Object.assign(wrapResult(configResult), { stop: configResult.stop });
        }
    }
    catch (error) {
        return {
            errors: [new config_errors_1.ConfigLoadError(`Error loading Stackbit configuration: ${error.message}`, { originalError: error })]
        };
    }
    return {
        errors: [
            new config_errors_1.ConfigLoadError('stackbit.yaml or stackbit.config.js was not found, please refer Stackbit documentation: https://www.stackbit.com/docs/stackbit-yaml/')
        ]
    };
}
exports.loadConfigFromDir = loadConfigFromDir;
async function loadConfigFromStackbitYaml(stackbitYamlPath) {
    const stackbitYaml = await fs_extra_1.default.readFile(stackbitYamlPath);
    const config = js_yaml_1.default.load(stackbitYaml.toString('utf8'), { schema: js_yaml_1.default.JSON_SCHEMA });
    if (!config || typeof config !== 'object') {
        return {
            error: new config_errors_1.ConfigLoadError('error parsing stackbit.yaml, please refer Stackbit documentation: https://www.stackbit.com/docs/stackbit-yaml/')
        };
    }
    return { config };
}
async function loadModelsFromFiles(dirPath, config) {
    const modelsSource = lodash_1.default.get(config, 'modelsSource', {});
    const sourceType = lodash_1.default.get(modelsSource, 'type', 'files');
    const defaultModelDirs = ['node_modules/@stackbit/components/models', '.stackbit/models'];
    const modelDirs = sourceType === 'files'
        ? lodash_1.default.castArray(lodash_1.default.get(modelsSource, 'modelDirs', defaultModelDirs)).map((modelDir) => lodash_1.default.trim(modelDir, '/'))
        : defaultModelDirs;
    const modelFiles = await utils_2.reducePromise(modelDirs, async (modelFiles, modelDir) => {
        const absModelsDir = path_1.default.join(dirPath, modelDir);
        const dirExists = await fs_extra_1.default.pathExists(absModelsDir);
        if (!dirExists) {
            return modelFiles;
        }
        const files = await readModelFilesFromDir(absModelsDir);
        return modelFiles.concat(files.map((filePath) => path_1.default.join(modelDir, filePath)));
    }, []);
    return utils_2.reducePromise(modelFiles, async (result, modelFile) => {
        let model;
        try {
            model = await utils_2.parseFile(path_1.default.join(dirPath, modelFile));
        }
        catch (error) {
            return {
                models: result.models,
                errors: result.errors.concat(new config_errors_1.ConfigLoadError(`error parsing model, file: ${modelFile}`))
            };
        }
        const modelName = model === null || model === void 0 ? void 0 : model.name;
        if (!modelName) {
            return {
                models: result.models,
                errors: result.errors.concat(new config_errors_1.ConfigLoadError(`model does not have a name, file: ${modelFile}`))
            };
        }
        result.models[modelName] = lodash_1.default.omit(model, 'name');
        result.models[modelName].__metadata = {
            filePath: modelFile
        };
        return result;
    }, { models: {}, errors: [] });
}
async function readModelFilesFromDir(modelsDir) {
    return await utils_2.readDirRecursively(modelsDir, {
        filter: (filePath, stats) => {
            if (stats.isDirectory()) {
                return true;
            }
            const extension = path_1.default.extname(filePath).substring(1);
            return stats.isFile() && ['yaml', 'yml'].includes(extension);
        }
    });
}
async function loadModelsFromExternalSource(config, dirPath, modelsSource) {
    modelsSource = lodash_1.default.assign({}, modelsSource, config.modelSource);
    const sourceType = lodash_1.default.get(modelsSource, 'type', 'files');
    if (sourceType === 'files') {
        // we already loaded models from files inside loadModelsFromFiles function
        return { models: [], errors: [] };
    }
    else if (sourceType === 'contentful') {
        const contentfulModule = lodash_1.default.get(modelsSource, 'module', '@stackbit/cms-contentful');
        const modulePath = path_1.default.resolve(dirPath, 'node_modules', contentfulModule);
        const module = await Promise.resolve().then(() => __importStar(require(modulePath)));
        try {
            const { models } = await module.fetchAndConvertSchema(lodash_1.default.omit(modelsSource, ['type', 'module']));
            return {
                models: models,
                errors: []
            };
        }
        catch (error) {
            return {
                models: [],
                errors: [new config_errors_1.ConfigLoadError(`Error fetching and converting Contentful schema, error: ${error.message}`, { originalError: error })]
            };
        }
    }
    return {
        models: [],
        errors: [new config_errors_1.ConfigLoadError(`modelsSource ${modelsSource} is unsupported`)]
    };
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function loadConfigFromDotStackbit(dirPath) {
    const stackbitDotPath = path_1.default.join(dirPath, '.stackbit');
    const stackbitDotExists = await fs_extra_1.default.pathExists(stackbitDotPath);
    if (!stackbitDotExists) {
        return null;
    }
    const config = {};
    const themeYaml = path_1.default.join(stackbitDotPath, 'theme.yaml');
    const themeYamlExists = await fs_extra_1.default.readFile(themeYaml);
    if (themeYamlExists) {
        const themeConfig = await fs_extra_1.default.readFile(themeYaml);
        lodash_1.default.assign(config, themeConfig);
    }
    const studioYaml = path_1.default.join(stackbitDotPath, 'studio.yaml');
    const studioYamlExists = await fs_extra_1.default.readFile(themeYaml);
    if (studioYamlExists) {
        const studioConfig = await fs_extra_1.default.readFile(studioYaml);
        lodash_1.default.assign(config, studioConfig);
    }
    const schemaYaml = path_1.default.join(stackbitDotPath, 'schema.yaml');
    const schemaYamlExists = await fs_extra_1.default.readFile(themeYaml);
    if (schemaYamlExists) {
        const schemaConfig = await fs_extra_1.default.readFile(schemaYaml);
        lodash_1.default.assign(config, schemaConfig);
    }
    return lodash_1.default.isEmpty(config) ? null : config;
}
function mergeConfigModelsWithModelsFromFiles(configModels, modelsFromFiles) {
    const mergedModels = lodash_1.default.mapValues(modelsFromFiles, (modelFromFile, modelName) => {
        var _a, _b, _c;
        // resolve thumbnails of models loaded from files
        const modelFilePath = (_a = modelFromFile.__metadata) === null || _a === void 0 ? void 0 : _a.filePath;
        resolveThumbnailPathForModel(modelFromFile, modelFilePath);
        utils_1.iterateModelFieldsRecursively(modelFromFile, (field) => {
            if (utils_1.isListField(field)) {
                field = utils_1.normalizeListFieldInPlace(field);
                field = field.items;
            }
            if (utils_1.isObjectField(field)) {
                resolveThumbnailPathForModel(field, modelFilePath);
            }
            else if (utils_1.isEnumField(field)) {
                resolveThumbnailPathForEnumField(field, modelFilePath);
            }
        });
        const configModel = lodash_1.default.get(configModels, modelName);
        if (!configModel) {
            return modelFromFile;
        }
        return lodash_1.default.assign({}, modelFromFile, configModel, {
            fields: lodash_1.default.unionBy((_b = configModel === null || configModel === void 0 ? void 0 : configModel.fields) !== null && _b !== void 0 ? _b : [], (_c = modelFromFile === null || modelFromFile === void 0 ? void 0 : modelFromFile.fields) !== null && _c !== void 0 ? _c : [], 'name')
        });
    });
    return Object.assign({}, configModels, mergedModels);
}
function mergeConfigWithExternalModels(config, externalModels) {
    var _a;
    if (!externalModels || externalModels.length === 0) {
        return {
            config,
            errors: []
        };
    }
    const stackbitModels = (_a = config === null || config === void 0 ? void 0 : config.models) !== null && _a !== void 0 ? _a : {};
    const errors = [];
    const models = lodash_1.default.reduce(externalModels, (modelMap, externalModel) => {
        const { name, ...rest } = externalModel;
        return Object.assign(modelMap, { [name]: rest });
    }, {});
    lodash_1.default.forEach(stackbitModels, (stackbitModel, modelName) => {
        var _a, _b;
        let externalModel = models[modelName];
        if (!externalModel) {
            return;
        }
        const modelType = stackbitModel.type ? (stackbitModel.type === 'config' ? 'data' : stackbitModel.type) : (_a = externalModel.type) !== null && _a !== void 0 ? _a : 'object';
        const urlPath = modelType === 'page' ? (_b = stackbitModel === null || stackbitModel === void 0 ? void 0 : stackbitModel.urlPath) !== null && _b !== void 0 ? _b : '/{slug}' : null;
        externalModel = Object.assign({}, externalModel, lodash_1.default.pick(stackbitModel, ['__metadata', 'label', 'description', 'thumbnail', 'singleInstance', 'readOnly', 'labelField', 'fieldGroups']), utils_2.omitByNil({
            type: modelType,
            urlPath
        }));
        externalModel = utils_1.mapModelFieldsRecursively(externalModel, (externalField, modelKeyPath) => {
            const stackbitField = utils_1.getModelFieldForModelKeyPath(stackbitModel, modelKeyPath);
            if (!stackbitField) {
                return externalField;
            }
            let override = {};
            if (externalField.type === 'json' && stackbitField.type === 'style') {
                override = stackbitField;
            }
            else if (externalField.type === 'string' && stackbitField.type === 'color') {
                override = { type: 'color' };
            }
            else if (externalField.type === 'enum') {
                override = lodash_1.default.pick(stackbitField, ['options']);
            }
            else if (externalField.type === 'number') {
                override = lodash_1.default.pick(stackbitField, ['subtype', 'min', 'max', 'step', 'unit']);
            }
            else if (externalField.type === 'object') {
                override = lodash_1.default.pick(stackbitField, ['labelField', 'thumbnail', 'fieldGroups']);
            }
            return Object.assign({}, externalField, lodash_1.default.pick(stackbitField, ['label', 'description', 'required', 'default', 'group', 'const', 'hidden', 'readOnly', 'controlType']), override);
        });
        models[modelName] = externalModel;
    });
    return {
        config: {
            ...config,
            models: models
        },
        errors: errors
    };
}
function normalizeConfig(config) {
    const pageLayoutKey = lodash_1.default.get(config, 'pageLayoutKey', 'layout');
    const objectTypeKey = lodash_1.default.get(config, 'objectTypeKey', 'type');
    const stackbitYamlVersion = String(lodash_1.default.get(config, 'stackbitVersion', ''));
    const ver = semver_1.default.coerce(stackbitYamlVersion);
    const isStackbitYamlV2 = ver ? semver_1.default.satisfies(ver, '<0.3.0') : false;
    const models = (config === null || config === void 0 ? void 0 : config.models) || {};
    const gitCMS = isGitCMS(config);
    lodash_1.default.forEach(models, (model, modelName) => {
        if (!model) {
            return;
        }
        if (!lodash_1.default.has(model, 'type')) {
            model.type = 'object';
        }
        // add model label if not set
        if (!lodash_1.default.has(model, 'label')) {
            model.label = lodash_1.default.startCase(modelName);
        }
        if (lodash_1.default.has(model, 'fields') && !Array.isArray(model.fields)) {
            model.fields = [];
        }
        if (utils_1.isPageModel(model)) {
            // rename old 'template' property to 'layout'
            utils_2.rename(model, 'template', 'layout');
            updatePageUrlPath(model);
            if (gitCMS) {
                updatePageFilePath(model, config);
                addMarkdownContentField(model);
            }
        }
        else if (utils_1.isDataModel(model) && gitCMS) {
            updateDataFilePath(model, config);
        }
        if (gitCMS) {
            // TODO: do not add pageLayoutKey and objectTypeKey fields to models,
            //  The content validator should always assume these fields.
            //  And when new objects created from UI, it should add these fields automatically.
            if (utils_1.isPageModel(model)) {
                addLayoutFieldToPageModel(model, pageLayoutKey, modelName);
            }
            else if (utils_1.isDataModel(model) && !utils_1.isListDataModel(model)) {
                addObjectTypeKeyField(model, objectTypeKey, modelName);
            }
        }
        if (utils_1.isListDataModel(model)) {
            // 'items.type' of list model defaults to 'string', set it explicitly
            if (!lodash_1.default.has(model, 'items.type')) {
                lodash_1.default.set(model, 'items.type', 'string');
            }
            if (utils_1.isObjectListItems(model.items)) {
                utils_1.assignLabelFieldIfNeeded(model.items);
            }
        }
        else if (!lodash_1.default.has(model, 'labelField')) {
            utils_1.assignLabelFieldIfNeeded(model);
        }
        utils_1.iterateModelFieldsRecursively(model, (field) => {
            // add field label if label is not set
            if (!lodash_1.default.has(field, 'label')) {
                field.label = lodash_1.default.startCase(field.name);
            }
            if (utils_1.isListField(field)) {
                field = utils_1.normalizeListFieldInPlace(field);
                field = field.items;
            }
            if (utils_1.isObjectField(field)) {
                utils_1.assignLabelFieldIfNeeded(field);
            }
            else if (utils_1.isCustomModelField(field, models)) {
                // stackbit v0.2.0 compatibility
                // convert the old custom model field type: { type: 'action' }
                // to the new 'model' field type: { type: 'model', models: ['action'] }
                field.models = [field.type];
                field.type = 'model';
            }
            else if (field.type === 'models') {
                // stackbit v0.2.0 compatibility
                // convert the old 'models' field type: { type: 'models', models: ['link', 'button'] }
                // to the new 'model' field type: { type: 'model', models: ['link', 'button'] }
                field.type = 'model';
                field.models = lodash_1.default.get(field, 'models', []);
            }
            else if (field.type === 'model' && lodash_1.default.has(field, 'model')) {
                // stackbit v0.2.0 compatibility
                // convert the old 'model' field type: { type: 'model', model: 'link' }
                // to the new 'model' field type: { type: 'model', models: ['link'] }
                field.models = [field.model];
                delete field.model;
            }
            if (isStackbitYamlV2) {
                // in stackbit.yaml v0.2.x, the 'reference' field was what we have today as 'model' field:
                if (utils_1.isReferenceField(field)) {
                    field = field;
                    field.type = 'model';
                    field.models = lodash_1.default.get(field, 'models', []);
                }
            }
        });
    });
    return config;
}
function updatePageUrlPath(model) {
    // set default urlPath if not set
    if (!model.urlPath) {
        model.urlPath = '/{slug}';
    }
}
/**
 * Sets the page model's filePath pattern.
 * If the model has `filePath` property, it is prefixed with `pagesDir` and returned.
 * If the model has no `filePath` property, then `filePath` is naively inferred by
 * prefixing `urlPath` with `pagesDir` and appending the `.md` extension.
 */
function updatePageFilePath(model, config) {
    var _a;
    let filePath;
    if (model.filePath) {
        filePath = model.filePath;
    }
    else if (model.file) {
        filePath = model.file;
    }
    else {
        const urlPath = model.urlPath;
        if (urlPath === '/') {
            filePath = 'index.md';
        }
        else if (lodash_1.default.trim(urlPath, '/') === 'posts/{slug}' && config.ssgName === 'jekyll') {
            filePath = '_posts/{moment_format("YYYY-MM-DD")}-{slug}.md';
        }
        else {
            filePath = lodash_1.default.trim(urlPath, '/') + '.md';
        }
    }
    const parentDir = lodash_1.default.trim((_a = config.pagesDir) !== null && _a !== void 0 ? _a : '', '/');
    model.filePath = path_1.default.join(parentDir, filePath);
}
function updateDataFilePath(model, config) {
    var _a;
    let filePath;
    if (model.filePath) {
        filePath = model.filePath;
    }
    else if (model.file) {
        filePath = model.file;
    }
    else {
        const folder = lodash_1.default.trim(lodash_1.default.get(model, 'folder'), '/');
        filePath = lodash_1.default.trim(`${folder}/{slug}.json`, '/');
    }
    const parentDir = lodash_1.default.trim((_a = config.dataDir) !== null && _a !== void 0 ? _a : '', '/');
    model.filePath = path_1.default.join(parentDir, filePath);
}
function addMarkdownContentField(model) {
    if (model.hideContent) {
        return;
    }
    const hasMarkdownContent = lodash_1.default.find(lodash_1.default.get(model, 'fields'), { name: 'markdown_content' });
    if (hasMarkdownContent) {
        return;
    }
    utils_2.append(model, 'fields', {
        type: 'markdown',
        name: 'markdown_content',
        label: 'Content',
        description: 'Page content'
    });
}
function addLayoutFieldToPageModel(model, pageLayoutKey, modelName) {
    if (lodash_1.default.intersection(lodash_1.default.keys(model), ['file', 'folder', 'match', 'exclude']).length === 0 && !lodash_1.default.get(model, 'layout')) {
        model.layout = modelName;
    }
    const modelLayout = lodash_1.default.get(model, 'layout');
    if (!modelLayout) {
        return;
    }
    const hasLayoutField = lodash_1.default.find(lodash_1.default.get(model, 'fields'), { name: pageLayoutKey });
    if (hasLayoutField) {
        return;
    }
    utils_2.prepend(model, 'fields', {
        type: 'string',
        name: pageLayoutKey,
        label: lodash_1.default.startCase(pageLayoutKey),
        const: modelLayout,
        hidden: true
    });
}
function addObjectTypeKeyField(model, objectTypeKey, modelName) {
    const hasObjectTypeField = lodash_1.default.find(lodash_1.default.get(model, 'fields'), { name: objectTypeKey });
    if (hasObjectTypeField) {
        return;
    }
    utils_2.prepend(model, 'fields', {
        type: 'string',
        name: objectTypeKey,
        label: 'Object Type',
        description: 'The type of the object',
        const: modelName,
        hidden: true
    });
}
function resolveThumbnailPathForModel(modelOrField, modelFilePath) {
    if (modelOrField.thumbnail && modelFilePath) {
        const modelDirPath = path_1.default.dirname(modelFilePath);
        modelOrField.thumbnail = resolveThumbnailPath(modelOrField.thumbnail, modelDirPath);
    }
}
function resolveThumbnailPathForEnumField(enumField, modelFilePath) {
    if (enumField.controlType === 'thumbnails' && modelFilePath) {
        const modelDirPath = path_1.default.dirname(modelFilePath);
        lodash_1.default.forEach(enumField.options, (option) => {
            if (option.thumbnail) {
                option.thumbnail = resolveThumbnailPath(option.thumbnail, modelDirPath);
            }
        });
    }
}
function resolveThumbnailPath(thumbnail, modelDirPath) {
    if (thumbnail.startsWith('//') || /https?:\/\//.test(thumbnail)) {
        return thumbnail;
    }
    if (thumbnail.startsWith('/')) {
        if (modelDirPath.endsWith('@stackbit/components/models')) {
            modelDirPath = modelDirPath.replace(/\/models$/, '');
        }
        else {
            modelDirPath = '';
        }
        thumbnail = thumbnail.replace(/^\//, '');
    }
    return path_1.default.join(modelDirPath, thumbnail);
}
/**
 * Returns model names referenced by polymorphic 'model' and 'reference' fields.
 * That is, fields that can hold objects of different types.
 *
 * @param field
 */
function getReferencedModelNames(field) {
    var _a, _b;
    if (utils_1.isListField(field)) {
        field = utils_1.getListFieldItems(field);
    }
    // TODO: add type field to model fields inside container update/create object logic rather adding type to schema
    // 'object' models referenced by 'model' fields should have 'type' field
    // if these fields have than 1 model.
    // 'data' models referenced by 'reference' fields should always have 'type' field.
    let referencedModelNames = [];
    if (utils_1.isModelField(field) && ((_a = field.models) === null || _a === void 0 ? void 0 : _a.length) > 1) {
        const modelNames = field.models;
        referencedModelNames = lodash_1.default.union(referencedModelNames, modelNames);
    }
    else if (utils_1.isReferenceField(field) && ((_b = field.models) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        const modelNames = field.models;
        referencedModelNames = lodash_1.default.union(referencedModelNames, modelNames);
    }
    return referencedModelNames;
}
function validateAndExtendContentModels(config) {
    var _a, _b;
    const contentModels = (_a = config.contentModels) !== null && _a !== void 0 ? _a : {};
    const models = (_b = config.models) !== null && _b !== void 0 ? _b : {};
    const externalModels = !isGitCMS(config);
    const emptyContentModels = lodash_1.default.isEmpty(contentModels);
    if (externalModels || emptyContentModels) {
        return {
            valid: true,
            value: config,
            errors: []
        };
    }
    const validationResult = config_validator_1.validateContentModels(contentModels, models);
    if (lodash_1.default.isEmpty(models)) {
        return {
            valid: validationResult.valid,
            value: config,
            errors: validationResult.errors
        };
    }
    const extendedModels = lodash_1.default.mapValues(models, (model, modelName) => {
        const contentModel = validationResult.value.contentModels[modelName];
        if (!contentModel) {
            return model;
        }
        if (lodash_1.default.get(contentModel, '__metadata.invalid')) {
            return model;
        }
        if (contentModel.isPage && (!model.type || ['object', 'page'].includes(model.type))) {
            return {
                type: 'page',
                ...(contentModel.newFilePath ? { filePath: contentModel.newFilePath } : {}),
                ...lodash_1.default.omit(contentModel, ['isPage', 'newFilePath']),
                ...lodash_1.default.omit(model, 'type')
            };
        }
        else if (!contentModel.isPage && (!model.type || ['object', 'data'].includes(model.type))) {
            return {
                type: 'data',
                ...(contentModel.newFilePath ? { filePath: contentModel.newFilePath } : {}),
                ...lodash_1.default.omit(contentModel, ['isPage', 'newFilePath']),
                ...lodash_1.default.omit(model, 'type')
            };
        }
        else {
            return model;
        }
    });
    return {
        valid: validationResult.valid,
        value: {
            ...config,
            models: extendedModels
        },
        errors: validationResult.errors
    };
}
function normalizeValidationResult(validationResult) {
    validationResult = filterAndOrderConfigFields(validationResult);
    convertModelGroupsToModelList(validationResult);
    return convertModelsToArray(validationResult);
}
function filterAndOrderConfigFields(validationResult) {
    // TODO: see if we move filtering and sorting to Joi
    return {
        ...validationResult,
        value: lodash_1.default.pick(validationResult.value, [
            'stackbitVersion',
            'ssgName',
            'ssgVersion',
            'cmsName',
            'import',
            'buildCommand',
            'publishDir',
            'nodeVersion',
            'devCommand',
            'staticDir',
            'uploadDir',
            'assets',
            'pagesDir',
            'dataDir',
            'pageLayoutKey',
            'objectTypeKey',
            'styleObjectModelName',
            'excludePages',
            'logicFields',
            'contentModels',
            'presetSource',
            'modelsSource',
            'models',
            'presets'
        ])
    };
}
function convertModelGroupsToModelList(validationResult) {
    var _a, _b;
    const models = (_b = (_a = validationResult.value) === null || _a === void 0 ? void 0 : _a.models) !== null && _b !== void 0 ? _b : {};
    const groupMap = lodash_1.default.reduce(models, (groupMap, model, modelName) => {
        if (!model.groups) {
            return groupMap;
        }
        const key = (model === null || model === void 0 ? void 0 : model.type) === 'object' ? 'objectModels' : 'documentModels';
        lodash_1.default.forEach(model.groups, (groupName) => {
            utils_2.append(groupMap, [groupName, key], modelName);
        });
        delete model.groups;
        return groupMap;
    }, {});
    // update groups to have unique model names
    lodash_1.default.forEach(groupMap, (group) => {
        lodash_1.default.forEach(group, (modelGroup, key) => {
            lodash_1.default.set(group, key, lodash_1.default.uniq(modelGroup));
        });
    });
    lodash_1.default.forEach(models, (model) => {
        utils_1.iterateModelFieldsRecursively(model, (field) => {
            if (utils_1.isListField(field)) {
                field = field.items;
            }
            if (field.groups) {
                let key = null;
                if (utils_1.isModelField(field)) {
                    key = 'objectModels';
                }
                else if (utils_1.isReferenceField(field)) {
                    key = 'documentModels';
                }
                if (key) {
                    field.models = lodash_1.default.reduce(field.groups, (modelNames, groupName) => {
                        const objectModelNames = lodash_1.default.get(groupMap, [groupName, key], []);
                        return lodash_1.default.uniq(modelNames.concat(objectModelNames));
                    }, field.models || []);
                }
                delete field.groups;
            }
        });
    });
}
function convertModelsToArray(validationResult) {
    var _a;
    const config = validationResult.value;
    // in stackbit.yaml 'models' are defined as object where keys are the model names,
    // convert 'models' to array of objects and set their 'name' property to the
    // model name
    const modelMap = (_a = config.models) !== null && _a !== void 0 ? _a : {};
    const modelArray = lodash_1.default.map(modelMap, (yamlModel, modelName) => {
        return {
            name: modelName,
            ...yamlModel
        };
    });
    if (!isGitCMS(config)) {
        addImageModel(modelArray);
    }
    const convertedErrors = lodash_1.default.map(validationResult.errors, (error) => {
        if (error.fieldPath[0] === 'models' && typeof error.fieldPath[1] == 'string') {
            const modelName = error.fieldPath[1];
            const modelIndex = lodash_1.default.findIndex(modelArray, { name: modelName });
            const normFieldPath = error.fieldPath.slice();
            normFieldPath[1] = modelIndex;
            error.normFieldPath = normFieldPath;
        }
        return error;
    });
    return {
        valid: validationResult.valid,
        config: {
            ...config,
            models: modelArray
        },
        errors: convertedErrors
    };
}
function addImageModel(models) {
    models.push({
        type: 'image',
        name: '__image_model',
        label: 'Image',
        labelField: 'title',
        fields: [
            { name: 'title', type: 'string' },
            { name: 'url', type: 'string' }
        ]
    });
}
function isGitCMS(config) {
    return !config.cmsName || config.cmsName === 'git';
}
//# sourceMappingURL=config-loader.js.map